#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Matilda Brain - Text to Text - A powerful AI assistant for your terminal
Generated by Goobits CLI Framework v

This is a consolidated Python CLI file with all utilities embedded.
Generated from: goobits.yaml
"""

import sys
import os
import logging
import traceback
from pathlib import Path
from typing import Any, Dict, Optional, List

import click
try:
    import tomllib
except ImportError:  # pragma: no cover
    tomllib = None
try:
    import toml
except ImportError:  # pragma: no cover
    toml = None
if tomllib is None and toml is None:  # pragma: no cover
    raise RuntimeError("No TOML parser available. Install 'toml' package or use Python 3.11+.")
# ============================================================================
# EMBEDDED LOGGER
# ============================================================================

class ColoredFormatter(logging.Formatter):
    """Custom formatter with color support."""

    COLORS = {
        'DEBUG': '\033[36m',    # Cyan
        'INFO': '\033[32m',     # Green
        'WARNING': '\033[33m',  # Yellow
        'ERROR': '\033[31m',    # Red
        'CRITICAL': '\033[35m', # Magenta
    }
    RESET = '\033[0m'

    def format(self, record):
        log_color = self.COLORS.get(record.levelname, self.RESET)
        record.levelname = f"{log_color}{record.levelname}{self.RESET}"
        return super().format(record)

def setup_logging(level=logging.INFO, log_file=None):
    """Configure logging for the CLI."""
    handlers = []

    # Console handler with colors
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(ColoredFormatter(
        '%(asctime)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    ))
    handlers.append(console_handler)

    # File handler if specified
    if log_file:
        file_handler = logging.FileHandler(log_file)
        file_handler.setFormatter(logging.Formatter(
            '%(asctime)s - %(levelname)s - %(name)s - %(message)s'
        ))
        handlers.append(file_handler)

    logging.basicConfig(
        level=level,
        handlers=handlers
    )

logger = logging.getLogger(__name__)

# ============================================================================
# EMBEDDED CONFIG MANAGER
# ============================================================================

class ConfigManager:
    """Manage CLI configuration."""

    def __init__(self, config_file: Optional[Path] = None):
        """Initialize configuration manager."""
        self.section = "brain"
        if config_file is None:
            env_path = os.environ.get("MATILDA_CONFIG")
            config_file = Path(env_path) if env_path else Path.home() / ".matilda" / "config.toml"

        self.config_file = Path(config_file)
        self.config_file.parent.mkdir(parents=True, exist_ok=True)
        self.config = self._load_config()

    def _load_config(self) -> Dict[str, Any]:
        """Load configuration from file."""
        if self.config_file.exists():
            try:
                parser = tomllib if tomllib is not None else toml
                with open(self.config_file, "rb") as f:
                    full_config = parser.load(f)
                section = full_config.get(self.section)
                if isinstance(section, dict):
                    return section
                return {}
            except Exception as e:
                logger.warning(f"Failed to load config: {e}")
                return {}
        return {}

    def save_config(self) -> bool:
        """Save configuration to file."""
        try:
            parser = tomllib if tomllib is not None else toml
            if self.config_file.exists():
                with open(self.config_file, "rb") as f:
                    full_config = parser.load(f)
            else:
                full_config = {}

            full_config[self.section] = self.config
            if toml is None:
                logger.error("Failed to save config: 'toml' package is required for writing TOML files.")
                return False
            with open(self.config_file, "w", encoding="utf-8") as f:
                f.write(toml.dumps(full_config))
            return True
        except Exception as e:
            logger.error(f"Failed to save config: {e}")
            return False

    def get(self, key: str, default: Any = None) -> Any:
        """Get configuration value."""
        keys = key.split(".")
        value = self.config
        for k in keys:
            if isinstance(value, dict):
                value = value.get(k)
                if value is None:
                    return default
            else:
                return default
        return value

    def set(self, key: str, value: Any):
        """Set configuration value."""
        keys = key.split(".")
        config = self.config
        for k in keys[:-1]:
            if k not in config:
                config[k] = {}
            config = config[k]
        config[keys[-1]] = value

# ============================================================================
# EMBEDDED ERROR HANDLER
# ============================================================================

class CLIError(Exception):
    """Base exception for CLI errors."""
    exit_code = 1

class UsageError(CLIError):
    """Exception for usage errors."""
    exit_code = 2

class ConfigError(CLIError):
    """Exception for configuration errors."""
    exit_code = 3

def handle_error(error: Exception, verbose: bool = False):
    """Handle CLI errors consistently."""
    if isinstance(error, CLIError):
        logger.error(str(error))
        if verbose:
            logger.debug(traceback.format_exc())
        sys.exit(error.exit_code)
    else:
        logger.error(f"Unexpected error: {error}")
        if verbose:
            logger.debug(traceback.format_exc())
        else:
            logger.info("Run with --verbose for more details")
        sys.exit(1)

# ============================================================================
# CLI CONTEXT
# ============================================================================

class CLIContext:
    """Shared context for CLI commands."""

    def __init__(self, config: ConfigManager, verbose: bool = False, debug: bool = False):
        self.config = config
        self.verbose = verbose
        self.debug = debug

        # Setup logging based on verbosity
        if debug:
            setup_logging(logging.DEBUG)
        elif verbose:
            setup_logging(logging.INFO)
        else:
            setup_logging(logging.WARNING)

# ============================================================================
# HOOK SYSTEM
# ============================================================================
def load_hooks():
    """Load user-defined hooks."""
    try:
        import matilda_brain.app_hooks as hooks_module
        return hooks_module
    except ImportError:
        logger.warning("No hooks module found. Please create one with your command implementations.")
        logger.warning("Example:")
        logger.warning("  def on_build(ctx, **kwargs):")
        logger.warning("      print('Build command implementation')")
        return None

_HOOKS_UNSET = object()
_hooks = _HOOKS_UNSET

def get_hooks():
    """Lazily load hooks to avoid import-time side effects."""
    global _hooks
    if _hooks is _HOOKS_UNSET:
        _hooks = load_hooks()
    return _hooks

def invoke_hook(ctx, hook_name: str, kwargs: Dict[str, Any]) -> None:
    """Invoke a hook by name or exit with a clear error."""
    hooks = get_hooks()
    if hooks and hasattr(hooks, hook_name):
        getattr(hooks, hook_name)(ctx=ctx, **kwargs)
        return
    logger.error(f"Hook '{hook_name}' not implemented in cli_hooks.py")
    sys.exit(1)

# ============================================================================
# CLI COMMANDS
# ============================================================================

@click.group()
@click.option('--verbose', '-v', is_flag=True, help='Enable verbose output')
@click.option('--debug', is_flag=True, help='Enable debug output')
@click.option('--config', type=click.Path(), help='Path to config file (default: ~/.matilda/config.toml)')
@click.pass_context
def cli(ctx, verbose, debug, config):
    """AI-powered conversations, straight from your command line"""
    config_path = Path(config) if config else None
    config_manager = ConfigManager(config_path)
    ctx.obj = CLIContext(config_manager, verbose, debug)

@cli.command('ask')
@click.argument('prompt', type=click.STRING, nargs=-1, default=None)
@click.option('--model', '-m', type=click.STRING, default=None,              help="LLM model to use")
@click.option('--temperature', '-t', type=click.FLOAT, default=0.7,              help="Sampling temperature (0.0-2.0)")
@click.option('--max-tokens', type=click.INT, default=None,              help="Maximum response length")
@click.option('--tools', is_flag=True, default=False,              help="Enable tool usage")
@click.option('--session', '-s', type=click.STRING, default=None,              help="Session ID for context")
@click.option('--system', type=click.STRING, default=None,              help="System prompt to set AI behavior")
@click.option('--stream', is_flag=True, default=True,              help="Stream the response")
@click.option('--json', is_flag=True, default=None,              help="Output response in JSON format")
@click.pass_obj
def ask(ctx, prompt, model, temperature, max_tokens, tools, session, system, stream, json):
    """Quickly ask one-off questions"""
    try:
        kwargs = {            'prompt': prompt,            'model': model,            'temperature': temperature,            'max_tokens': max_tokens,            'tools': tools,            'session': session,            'system': system,            'stream': stream,            'json': json,        }
        invoke_hook(ctx, 'on_ask', kwargs)
    except Exception as e:
        handle_error(e, ctx.verbose)
@cli.command('chat')
@click.option('--model', '-m', type=click.STRING, default=None,              help="LLM model to use")
@click.option('--session', '-s', type=click.STRING, default=None,              help="Session ID to resume or create")
@click.option('--tools', is_flag=True, default=False,              help="Enable tool usage in chat")
@click.option('--markdown', is_flag=True, default=True,              help="Render markdown in responses")
@click.pass_obj
def chat(ctx, model, session, tools, markdown):
    """Chat interactively with AI"""
    try:
        kwargs = {            'model': model,            'session': session,            'tools': tools,            'markdown': markdown,        }
        invoke_hook(ctx, 'on_chat', kwargs)
    except Exception as e:
        handle_error(e, ctx.verbose)
@cli.command('stateless')
@click.argument('message', type=click.STRING, nargs=-1, default=None)
@click.option('--system', type=click.STRING, default=None,              help="System prompt to set context")
@click.option('--history', type=click.STRING, default=None,              help="Path to JSON file with conversation history")
@click.option('--tools', type=click.STRING, default=None,              help="Comma-separated tool names to enable")
@click.option('--model', '-m', type=click.STRING, default=None,              help="LLM model to use")
@click.option('--temperature', '-t', type=click.FLOAT, default=0.7,              help="Sampling temperature (0.0-2.0)")
@click.option('--max-tokens', type=click.INT, default=2048,              help="Maximum response length")
@click.pass_obj
def stateless(ctx, message, system, history, tools, model, temperature, max_tokens):
    """Execute stateless AI request without session"""
    try:
        kwargs = {            'message': message,            'system': system,            'history': history,            'tools': tools,            'model': model,            'temperature': temperature,            'max_tokens': max_tokens,        }
        invoke_hook(ctx, 'on_stateless', kwargs)
    except Exception as e:
        handle_error(e, ctx.verbose)
@cli.command('list')
@click.argument('resource', type=click.STRING, required=False, default=None)
@click.option('--format', '-f', type=click.STRING, default='table',              help="Output format")
@click.pass_obj
def list(ctx, resource, format):
    """See available resources"""
    try:
        kwargs = {            'resource': resource,            'format': format,        }
        invoke_hook(ctx, 'on_list', kwargs)
    except Exception as e:
        handle_error(e, ctx.verbose)
@cli.command('status')
@click.option('--json', is_flag=True, default=None,              help="Output status in JSON format")
@click.pass_obj
def status(ctx, json):
    """Verify system and API health"""
    try:
        kwargs = {            'json': json,        }
        invoke_hook(ctx, 'on_status', kwargs)
    except Exception as e:
        handle_error(e, ctx.verbose)
@cli.command('models')
@click.option('--json', is_flag=True, default=None,              help="Output models in JSON format")
@click.pass_obj
def models(ctx, json):
    """View AI models"""
    try:
        kwargs = {            'json': json,        }
        invoke_hook(ctx, 'on_models', kwargs)
    except Exception as e:
        handle_error(e, ctx.verbose)
@cli.command('info')
@click.argument('model', type=click.STRING, required=False, default=None)
@click.option('--json', is_flag=True, default=None,              help="Output model info in JSON format")
@click.pass_obj
def info(ctx, model, json):
    """Detailed model information"""
    try:
        kwargs = {            'model': model,            'json': json,        }
        invoke_hook(ctx, 'on_info', kwargs)
    except Exception as e:
        handle_error(e, ctx.verbose)
@cli.command('export')
@click.argument('session', type=click.STRING, required=False, default=None)
@click.option('--format', '-f', type=click.STRING, default='markdown',              help="Export format")
@click.option('--output', '-o', type=click.STRING, default=None,              help="Output file path")
@click.option('--include-metadata', is_flag=True, default=False,              help="Include timestamps and model info")
@click.pass_obj
def export(ctx, session, format, output, include_metadata):
    """Save your chat history"""
    try:
        kwargs = {            'session': session,            'format': format,            'output': output,            'include_metadata': include_metadata,        }
        invoke_hook(ctx, 'on_export', kwargs)
    except Exception as e:
        handle_error(e, ctx.verbose)
@cli.group('config')
@click.pass_obj
def config_group(ctx):
    """Customize your setup"""
    pass
@config_group.command('get')
@click.argument('key', type=click.STRING)
@click.pass_obj
def config_get(ctx, key):
    """Get a configuration value"""
    try:
        kwargs = {            'key': key,        }
        invoke_hook(ctx, 'on_get', kwargs)
    except Exception as e:
        handle_error(e, ctx.verbose)

@config_group.command('set')
@click.argument('key', type=click.STRING)
@click.argument('value', type=click.STRING)
@click.pass_obj
def config_set(ctx, key, value):
    """Set a configuration value"""
    try:
        kwargs = {            'key': key,            'value': value,        }
        invoke_hook(ctx, 'on_set', kwargs)
    except Exception as e:
        handle_error(e, ctx.verbose)

@config_group.command('list')
@click.option('--show-secrets', is_flag=True, default=False,              help="Include API keys in output")
@click.pass_obj
def config_list(ctx, show_secrets):
    """List all configuration"""
    try:
        kwargs = {            'show_secrets': show_secrets,        }
        invoke_hook(ctx, 'on_list', kwargs)
    except Exception as e:
        handle_error(e, ctx.verbose)
@cli.group('tools')
@click.pass_obj
def tools_group(ctx):
    """Manage CLI tools and extensions"""
    pass
@tools_group.command('enable')
@click.argument('tool_name', type=click.STRING)
@click.pass_obj
def tools_enable(ctx, tool_name):
    """Enable a tool"""
    try:
        kwargs = {            'tool_name': tool_name,        }
        invoke_hook(ctx, 'on_enable', kwargs)
    except Exception as e:
        handle_error(e, ctx.verbose)

@tools_group.command('disable')
@click.argument('tool_name', type=click.STRING)
@click.pass_obj
def tools_disable(ctx, tool_name):
    """Disable a tool"""
    try:
        kwargs = {            'tool_name': tool_name,        }
        invoke_hook(ctx, 'on_disable', kwargs)
    except Exception as e:
        handle_error(e, ctx.verbose)

@tools_group.command('list')
@click.option('--show-disabled', is_flag=True, default=False,              help="Include disabled tools")
@click.pass_obj
def tools_list(ctx, show_disabled):
    """List all tools"""
    try:
        kwargs = {            'show_disabled': show_disabled,        }
        invoke_hook(ctx, 'on_list', kwargs)
    except Exception as e:
        handle_error(e, ctx.verbose)
@cli.command('serve')
@click.option('--host', type=click.STRING, default='0.0.0.0',              help="Host address to bind to")
@click.option('--port', '-p', type=click.INT, default=8772,              help="Port to listen on")
@click.pass_obj
def serve(ctx, host, port):
    """Start TTT HTTP server for browser clients"""
    try:
        kwargs = {            'host': host,            'port': port,        }
        invoke_hook(ctx, 'on_serve', kwargs)
    except Exception as e:
        handle_error(e, ctx.verbose)

# ============================================================================
# INTERACTIVE MODE (if enabled)
# ============================================================================
# ============================================================================
# MAIN ENTRY POINT
# ============================================================================

def main():
    """Main entry point for the CLI."""
    try:
        cli()
    except Exception as e:
        handle_error(e, '--verbose' in sys.argv or '--debug' in sys.argv)

if __name__ == '__main__':
    main()